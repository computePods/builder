{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Compute Pods Documentation This directory contains some simple documentation for the (ongoing) development and (eventually) use of the Compute Pods system. A previous attempt at a solution to a similar problem can be found at ConTeXtNursery .","title":"Compute Pods Documentation"},{"location":"#compute-pods-documentation","text":"This directory contains some simple documentation for the (ongoing) development and (eventually) use of the Compute Pods system. A previous attempt at a solution to a similar problem can be found at ConTeXtNursery .","title":"Compute Pods Documentation"},{"location":"architecture/Readme/","text":"Overall architecture A ComputePods \"pod\" is an coordinated collection of OCI Container containers. These ComputePods pods can be run rootless using Podman Pod (on a private collection of computers to which a user has access) or as a Kubernetes Pod (in a more specialized production environment). Each pod consists of: A NATS container used to provide inter/intra pod communication. A Syncthing container used to syncronize files between pods. A collection of different \"worker\" containers, one or more for each computational task. These worker containers consist a GoLang controler process which forks \"tasks\" consisting of any containerizable compuational \"command line\" process. This simple architecture is sufficent to parallelize any embarasingly parallelizable computational task (such as, but not limited to, compilation of source code). Suitably programmed computational tasks can interact with the NATS \"back-plane\" to initiate, and wait for sub-tasks to be run. Similarly, suitably programmed tasks can interact with the Syncthing \"back-plane\" to ensure all required files are syncronized between workers potentially contained in pods on different computers. Security All data flows between pods and the containers inside pods will be done using double-ended TLS . This means that all pods (and end-users) are assigned individual TLS certificates and all connections require TLS certificates from both the \"server\" and the \"client\". This security regime should work in both the Podman (tested) and Kubernetes (untested) environments.","title":"Overall architecture"},{"location":"architecture/Readme/#overall-architecture","text":"A ComputePods \"pod\" is an coordinated collection of OCI Container containers. These ComputePods pods can be run rootless using Podman Pod (on a private collection of computers to which a user has access) or as a Kubernetes Pod (in a more specialized production environment). Each pod consists of: A NATS container used to provide inter/intra pod communication. A Syncthing container used to syncronize files between pods. A collection of different \"worker\" containers, one or more for each computational task. These worker containers consist a GoLang controler process which forks \"tasks\" consisting of any containerizable compuational \"command line\" process. This simple architecture is sufficent to parallelize any embarasingly parallelizable computational task (such as, but not limited to, compilation of source code). Suitably programmed computational tasks can interact with the NATS \"back-plane\" to initiate, and wait for sub-tasks to be run. Similarly, suitably programmed tasks can interact with the Syncthing \"back-plane\" to ensure all required files are syncronized between workers potentially contained in pods on different computers.","title":"Overall architecture"},{"location":"architecture/Readme/#security","text":"All data flows between pods and the containers inside pods will be done using double-ended TLS . This means that all pods (and end-users) are assigned individual TLS certificates and all connections require TLS certificates from both the \"server\" and the \"client\". This security regime should work in both the Podman (tested) and Kubernetes (untested) environments.","title":"Security"},{"location":"developmentTasks/Readme/","text":"Developmental Tasks This directory contains a semi-ordered collection of tasks and their analysis. These tasks represent the initial steps in building the Compute Pods system.","title":"Developmental Tasks"},{"location":"developmentTasks/Readme/#developmental-tasks","text":"This directory contains a semi-ordered collection of tasks and their analysis. These tasks represent the initial steps in building the Compute Pods system.","title":"Developmental Tasks"},{"location":"developmentTasks/task001-embed-lua-in-golang/","text":"Provide project interface to an embeded Lua instance inside GoLang Started : 2021-03-03 (Essentially) Completed : 2021-03-03 Goal We want to use Lua (version 5.4) as a simple configuraiton/scripting langage inside most of our GoLang based tools. Solution We will use our own diSimplex fork of golua . This fork contains minor updates to make it compatible with Lua 5.4 on linux machines. The original golua can be found here . Problems At the moment there does not seem to be a ToInteger or ToFloat method in goLua. (Lua 5.1 forced all numbers as Integers, sometime before Lua 5.4 floats were added). We may need to fork goLua to explicitly add number handling. Line 22 in the file lua/lua.go defines the cgo LDFLAGS for the lua54 compile tag (for Lua 5.4). Unfortunately we need to explicitly add a -ldl to the existing LDFLAGS. Questions Q : How do we map Lua values to Go values? A : We can use goLua's standard stack mechanism and the associated IsXXX / PushXXX / ToXXX methods. We can also consider using either of the Luar or lunatico reflection mechanisms. Q : Should we link against a shared or statically built Lua library? If the only version of the Lua library is statically built, then cgo successfully links this version (but the LDFLAGS do need the additional -ldl flag, since Lua 5.4 now allows dynamic libraries). If both the static and the shared Lua libraries are pressent, I suspect cgo is linking the shared version in preference to the static version. SO this is really a question of how we want to build and distribute the Lua 5.4 libraries in the containers. This might be very important for any use of the Alpine based containers. This is also a question for building and distributing the assembly tools. In particular if we link to the static library, how do we distribute any pure Lua scripts? Resources Lua 5.4 documentation golua","title":"Provide project interface to an embeded Lua instance inside GoLang"},{"location":"developmentTasks/task001-embed-lua-in-golang/#provide-project-interface-to-an-embeded-lua-instance-inside-golang","text":"Started : 2021-03-03 (Essentially) Completed : 2021-03-03","title":"Provide project interface to an embeded Lua instance inside GoLang"},{"location":"developmentTasks/task001-embed-lua-in-golang/#goal","text":"We want to use Lua (version 5.4) as a simple configuraiton/scripting langage inside most of our GoLang based tools.","title":"Goal"},{"location":"developmentTasks/task001-embed-lua-in-golang/#solution","text":"We will use our own diSimplex fork of golua . This fork contains minor updates to make it compatible with Lua 5.4 on linux machines. The original golua can be found here .","title":"Solution"},{"location":"developmentTasks/task001-embed-lua-in-golang/#problems","text":"At the moment there does not seem to be a ToInteger or ToFloat method in goLua. (Lua 5.1 forced all numbers as Integers, sometime before Lua 5.4 floats were added). We may need to fork goLua to explicitly add number handling. Line 22 in the file lua/lua.go defines the cgo LDFLAGS for the lua54 compile tag (for Lua 5.4). Unfortunately we need to explicitly add a -ldl to the existing LDFLAGS.","title":"Problems"},{"location":"developmentTasks/task001-embed-lua-in-golang/#questions","text":"Q : How do we map Lua values to Go values? A : We can use goLua's standard stack mechanism and the associated IsXXX / PushXXX / ToXXX methods. We can also consider using either of the Luar or lunatico reflection mechanisms. Q : Should we link against a shared or statically built Lua library? If the only version of the Lua library is statically built, then cgo successfully links this version (but the LDFLAGS do need the additional -ldl flag, since Lua 5.4 now allows dynamic libraries). If both the static and the shared Lua libraries are pressent, I suspect cgo is linking the shared version in preference to the static version. SO this is really a question of how we want to build and distribute the Lua 5.4 libraries in the containers. This might be very important for any use of the Alpine based containers. This is also a question for building and distributing the assembly tools. In particular if we link to the static library, how do we distribute any pure Lua scripts?","title":"Questions"},{"location":"developmentTasks/task001-embed-lua-in-golang/#resources","text":"Lua 5.4 documentation golua","title":"Resources"},{"location":"developmentTasks/task002-provide-system-configuration/","text":"Provide tool to configure overall system Goal Provide an extensible configuration system for the Compute Pods system. Solution Configuration will consist of: - DNS names of each pod Problems Each pod will have (potentially) different configuration. We need to be able to split the overall configuration across multiple sub-files. Questions Resources Re: Lua as a \"domain specific language\"?","title":"Provide tool to configure overall system"},{"location":"developmentTasks/task002-provide-system-configuration/#provide-tool-to-configure-overall-system","text":"","title":"Provide tool to configure overall system"},{"location":"developmentTasks/task002-provide-system-configuration/#goal","text":"Provide an extensible configuration system for the Compute Pods system.","title":"Goal"},{"location":"developmentTasks/task002-provide-system-configuration/#solution","text":"Configuration will consist of:","title":"Solution"},{"location":"developmentTasks/task002-provide-system-configuration/#-dns-names-of-each-pod","text":"","title":"- DNS names of each pod"},{"location":"developmentTasks/task002-provide-system-configuration/#problems","text":"Each pod will have (potentially) different configuration. We need to be able to split the overall configuration across multiple sub-files.","title":"Problems"},{"location":"developmentTasks/task002-provide-system-configuration/#questions","text":"","title":"Questions"},{"location":"developmentTasks/task002-provide-system-configuration/#resources","text":"Re: Lua as a \"domain specific language\"?","title":"Resources"},{"location":"developmentTasks/task003-provide-pod-assembling-tool/","text":"Provide sketeton of a pod assembling tool Started : 2021-03-03 Goal We want a tool which reads a Lua configuration file and assembles the commands required to build and run a Podman pod. This tool should: Build the individual containers. Provide an ash shell script which can be used to run the pod using podman. This tool will probably make use of one or more templating systems to generate the required container build files and podman ash shell scripts. (Among many other tasks). Solution Subtasks Skectch build of NGinx container Skectch build of NATS container Skectch build of Syncthing container Skectch build of GCC container Skectch build of ConTeXt container Problems We are not sure what platforms these tools will be used on... will we have access to POSXI shell scripting? Questions Q : Should we use Buildah libraries to directly construct containers? A : No. We might consider this if the buildah project provided a stable GoLang API. However the current buildah project only provides a stable command-line interface. (The Open Repository for Container Tools does provide GoLang APIs but they look more complex than we want to use). Instead we should simply use Podman's (or Docker's) dockerfile system to build our containers, since podman (or podman/kubernetes, or docker/kubernetes) is already a runtime dependency. Using dockerfiles also makes sense since they are so well known and have many examplars from which to base new variants required for a given task worker. Q : What directory structure should we use to contain the (potentially) multiple artefacts required to build a single container. Q : Will all pods have the same containers? A : No. Q : Will all pods have the same open ports? A : No, since these pods might be run on other user's computers, we can not expect to have the same ports open on their firewalls. Indeed we need to make sure we expect as few ports as possible, and all ports should be above the \"root-only\" 1024 boundary on Linux/Unix. Q : Can the NATS and Syncthing ports be multi-plexed using NGinx? A : No. (Nor any other TCP based server -- at least not without changing the NATS/Syncthing protocols). SO we need to use NGinx to reverse proxy the HTTPS traffic, and use as few non-HTTPS ports as possible. Resources Dockerfiles nginxinc/docker-nginx (BSD 2 clause) nats-io/nats-docker (Apache 2.0) syncthing/syncthing (MPL 2.0) docker-library/gcc (GPL 3.0) islandoftex/images/context (MIT) Buildah libraries Buildah Buildah Blogs Buildah Tutorials Include Buildah in your build tool Building with Buildah: Dockerfiles, command line, or scripts GoLang Templating tex/template Lua Templating Using Lua as a Templating Engine [Lua Template Engine Revisited])(https://nachtimwald.com/2015/05/07/lua-template-engine-revisited/) Introducing Lua Templates arcapos/luatemplate (most active GitHub project; last changed 2 months ago; documented in the blog listed above). bungle/lua-resty-template (last changed 5 months ago; reasonably well documented) dannote/lua-template (oldest GitHub project; last changed 2 years ago; very small code base but allows external sub-templates)","title":"Provide sketeton of a pod assembling tool"},{"location":"developmentTasks/task003-provide-pod-assembling-tool/#provide-sketeton-of-a-pod-assembling-tool","text":"Started : 2021-03-03","title":"Provide sketeton of a pod assembling tool"},{"location":"developmentTasks/task003-provide-pod-assembling-tool/#goal","text":"We want a tool which reads a Lua configuration file and assembles the commands required to build and run a Podman pod. This tool should: Build the individual containers. Provide an ash shell script which can be used to run the pod using podman. This tool will probably make use of one or more templating systems to generate the required container build files and podman ash shell scripts. (Among many other tasks).","title":"Goal"},{"location":"developmentTasks/task003-provide-pod-assembling-tool/#solution","text":"","title":"Solution"},{"location":"developmentTasks/task003-provide-pod-assembling-tool/#subtasks","text":"Skectch build of NGinx container Skectch build of NATS container Skectch build of Syncthing container Skectch build of GCC container Skectch build of ConTeXt container","title":"Subtasks"},{"location":"developmentTasks/task003-provide-pod-assembling-tool/#problems","text":"We are not sure what platforms these tools will be used on... will we have access to POSXI shell scripting?","title":"Problems"},{"location":"developmentTasks/task003-provide-pod-assembling-tool/#questions","text":"Q : Should we use Buildah libraries to directly construct containers? A : No. We might consider this if the buildah project provided a stable GoLang API. However the current buildah project only provides a stable command-line interface. (The Open Repository for Container Tools does provide GoLang APIs but they look more complex than we want to use). Instead we should simply use Podman's (or Docker's) dockerfile system to build our containers, since podman (or podman/kubernetes, or docker/kubernetes) is already a runtime dependency. Using dockerfiles also makes sense since they are so well known and have many examplars from which to base new variants required for a given task worker. Q : What directory structure should we use to contain the (potentially) multiple artefacts required to build a single container. Q : Will all pods have the same containers? A : No. Q : Will all pods have the same open ports? A : No, since these pods might be run on other user's computers, we can not expect to have the same ports open on their firewalls. Indeed we need to make sure we expect as few ports as possible, and all ports should be above the \"root-only\" 1024 boundary on Linux/Unix. Q : Can the NATS and Syncthing ports be multi-plexed using NGinx? A : No. (Nor any other TCP based server -- at least not without changing the NATS/Syncthing protocols). SO we need to use NGinx to reverse proxy the HTTPS traffic, and use as few non-HTTPS ports as possible.","title":"Questions"},{"location":"developmentTasks/task003-provide-pod-assembling-tool/#resources","text":"","title":"Resources"},{"location":"developmentTasks/task003-provide-pod-assembling-tool/#dockerfiles","text":"nginxinc/docker-nginx (BSD 2 clause) nats-io/nats-docker (Apache 2.0) syncthing/syncthing (MPL 2.0) docker-library/gcc (GPL 3.0) islandoftex/images/context (MIT)","title":"Dockerfiles"},{"location":"developmentTasks/task003-provide-pod-assembling-tool/#buildah-libraries","text":"Buildah Buildah Blogs Buildah Tutorials Include Buildah in your build tool Building with Buildah: Dockerfiles, command line, or scripts","title":"Buildah libraries"},{"location":"developmentTasks/task003-provide-pod-assembling-tool/#golang-templating","text":"tex/template","title":"GoLang Templating"},{"location":"developmentTasks/task003-provide-pod-assembling-tool/#lua-templating","text":"Using Lua as a Templating Engine [Lua Template Engine Revisited])(https://nachtimwald.com/2015/05/07/lua-template-engine-revisited/) Introducing Lua Templates arcapos/luatemplate (most active GitHub project; last changed 2 months ago; documented in the blog listed above). bungle/lua-resty-template (last changed 5 months ago; reasonably well documented) dannote/lua-template (oldest GitHub project; last changed 2 years ago; very small code base but allows external sub-templates)","title":"Lua Templating"},{"location":"developmentTasks/task003a-assemble-pods-with-nats/","text":"Assemble a pod with NATS","title":"Assemble a pod with NATS"},{"location":"developmentTasks/task003a-assemble-pods-with-nats/#assemble-a-pod-with-nats","text":"","title":"Assemble a pod with NATS"},{"location":"developmentTasks/task00x-assemble-pods-with-syncthing/","text":"Assemble a pod with syncthing (with NATS)","title":"Assemble a pod with syncthing (with NATS)"},{"location":"developmentTasks/task00x-assemble-pods-with-syncthing/#assemble-a-pod-with-syncthing-with-nats","text":"","title":"Assemble a pod with syncthing (with NATS)"},{"location":"developmentTasks/task00x-provide-task-assembling-tool/","text":"Provide a tool to assemble container images for worker tasks Started : not yet begun Goal We want a tool which reads a Lua configuration file and builds a container. This tool will probably make use of one or more templating systems to generate the required container build files. (Among many other tasks). Solution Subtasks Skectch build of NATS container Skectch build of Syncthing container Skectch build of GCC container Problems We are not sure what platforms these tools will be used on... will we have access to POSXI shell scripting? Questions Q : Should we use Buildah libraries to directly construct containers? A : No. We might consider this if the buildah project provided a stable GoLang API. However the current buildah project only provides a stable command-line interface. (The Open Repository fo Container Tools does provide GoLang APIs but they look more complex than we want to use). Instead we should simply use Podman's (or Docker's) dockerfile system to build our containers, since podman (or podman/kubernetes, or docker/kubernetes) is already a runtime dependency. Using dockerfiles also makes sense since they are so well known and have many examplars from which to base new variants required for a given task worker. Q : What directory structure should we use to contain the (potentially) multiple artefacts required to build a single container. Resources Buildah libraries Buildah Buildah Blogs Buildah Tutorials Include Buildah in your build tool Building with Buildah: Dockerfiles, command line, or scripts GoLang Templating tex/template Lua Templating Using Lua as a Templating Engine [Lua Template Engine Revisited])(https://nachtimwald.com/2015/05/07/lua-template-engine-revisited/) Introducing Lua Templates arcapos/luatemplate (most active GitHub project; last changed 2 months ago; documented in the blog listed above). bungle/lua-resty-template (last changed 5 months ago; reasonably well documented) dannote/lua-template (oldest GitHub project; last changed 2 years ago; very small code base but allows external sub-templates)","title":"Provide a tool to assemble container images for worker tasks"},{"location":"developmentTasks/task00x-provide-task-assembling-tool/#provide-a-tool-to-assemble-container-images-for-worker-tasks","text":"Started : not yet begun","title":"Provide a tool to assemble container images for worker tasks"},{"location":"developmentTasks/task00x-provide-task-assembling-tool/#goal","text":"We want a tool which reads a Lua configuration file and builds a container. This tool will probably make use of one or more templating systems to generate the required container build files. (Among many other tasks).","title":"Goal"},{"location":"developmentTasks/task00x-provide-task-assembling-tool/#solution","text":"","title":"Solution"},{"location":"developmentTasks/task00x-provide-task-assembling-tool/#subtasks","text":"Skectch build of NATS container Skectch build of Syncthing container Skectch build of GCC container","title":"Subtasks"},{"location":"developmentTasks/task00x-provide-task-assembling-tool/#problems","text":"We are not sure what platforms these tools will be used on... will we have access to POSXI shell scripting?","title":"Problems"},{"location":"developmentTasks/task00x-provide-task-assembling-tool/#questions","text":"Q : Should we use Buildah libraries to directly construct containers? A : No. We might consider this if the buildah project provided a stable GoLang API. However the current buildah project only provides a stable command-line interface. (The Open Repository fo Container Tools does provide GoLang APIs but they look more complex than we want to use). Instead we should simply use Podman's (or Docker's) dockerfile system to build our containers, since podman (or podman/kubernetes, or docker/kubernetes) is already a runtime dependency. Using dockerfiles also makes sense since they are so well known and have many examplars from which to base new variants required for a given task worker. Q : What directory structure should we use to contain the (potentially) multiple artefacts required to build a single container.","title":"Questions"},{"location":"developmentTasks/task00x-provide-task-assembling-tool/#resources","text":"","title":"Resources"},{"location":"developmentTasks/task00x-provide-task-assembling-tool/#buildah-libraries","text":"Buildah Buildah Blogs Buildah Tutorials Include Buildah in your build tool Building with Buildah: Dockerfiles, command line, or scripts","title":"Buildah libraries"},{"location":"developmentTasks/task00x-provide-task-assembling-tool/#golang-templating","text":"tex/template","title":"GoLang Templating"},{"location":"developmentTasks/task00x-provide-task-assembling-tool/#lua-templating","text":"Using Lua as a Templating Engine [Lua Template Engine Revisited])(https://nachtimwald.com/2015/05/07/lua-template-engine-revisited/) Introducing Lua Templates arcapos/luatemplate (most active GitHub project; last changed 2 months ago; documented in the blog listed above). bungle/lua-resty-template (last changed 5 months ago; reasonably well documented) dannote/lua-template (oldest GitHub project; last changed 2 years ago; very small code base but allows external sub-templates)","title":"Lua Templating"},{"location":"developmentTasks/task00x-provide-tls-certificate-managment-tool/","text":"Provide tool to manage TLS certificates","title":"Provide tool to manage TLS certificates"},{"location":"developmentTasks/task00x-provide-tls-certificate-managment-tool/#provide-tool-to-manage-tls-certificates","text":"","title":"Provide tool to manage TLS certificates"},{"location":"using/Readme/","text":"Using the Compute Pods system A running Compute Pods system is a loose federation of individual Compute Pods one on each of a number of computers. These computers can be dedicated servers, Kubernetes nodes, or they could be \"desktops\" some of whose compute cycles are being contributed by their individual users. All of these computers must be connected by a network via either a private local area network, a virtual private network, or the greater Internet. All of these computers must allow TCP traffic through their firewalls on a small number of control ports. Setting up a federation of Compute Pods consists of a number of steps. Describe the overall system. Build the Containers required by the system. Deploy a Compute Pod to one or more computers in the system.","title":"Using the Compute Pods system"},{"location":"using/Readme/#using-the-compute-pods-system","text":"A running Compute Pods system is a loose federation of individual Compute Pods one on each of a number of computers. These computers can be dedicated servers, Kubernetes nodes, or they could be \"desktops\" some of whose compute cycles are being contributed by their individual users. All of these computers must be connected by a network via either a private local area network, a virtual private network, or the greater Internet. All of these computers must allow TCP traffic through their firewalls on a small number of control ports. Setting up a federation of Compute Pods consists of a number of steps. Describe the overall system. Build the Containers required by the system. Deploy a Compute Pod to one or more computers in the system.","title":"Using the Compute Pods system"},{"location":"using/buildContainers/","text":"Building the Containers required by the system","title":"Building the Containers required by the system"},{"location":"using/buildContainers/#building-the-containers-required-by-the-system","text":"","title":"Building the Containers required by the system"},{"location":"using/deployComputePod/","text":"Deploying a Compute Pod","title":"Deploying a Compute Pod"},{"location":"using/deployComputePod/#deploying-a-compute-pod","text":"","title":"Deploying a Compute Pod"},{"location":"using/describeSystem/","text":"Describing the overall Compute Pods system The Compute Pods communicate via TLS which is secured at both ends using a client/server certificate. Each individual Compute Pod is assigned its own client/server certificate. To be able to do this, each Compute Pod needs to be described before being deployed. Similarly each Compute Pod requires a number of different TCP ports for communication between pods. Since Compute Pods are meant to be run-able on various compute platforms (including \"desktops\"), there is a potential for these TCP ports to assigned to other tasks. This means that all of these communications ports must be configurable. Similarly each Compute Pod requires a host directory in which to synchronize files between the pods. Similarly each user requires their own client certificate. Since we will be issuing certificates, we need to define the (private) Certificate Auhority which will issue these certificates.","title":"Describing the overall Compute Pods system"},{"location":"using/describeSystem/#describing-the-overall-compute-pods-system","text":"The Compute Pods communicate via TLS which is secured at both ends using a client/server certificate. Each individual Compute Pod is assigned its own client/server certificate. To be able to do this, each Compute Pod needs to be described before being deployed. Similarly each Compute Pod requires a number of different TCP ports for communication between pods. Since Compute Pods are meant to be run-able on various compute platforms (including \"desktops\"), there is a potential for these TCP ports to assigned to other tasks. This means that all of these communications ports must be configurable. Similarly each Compute Pod requires a host directory in which to synchronize files between the pods. Similarly each user requires their own client certificate. Since we will be issuing certificates, we need to define the (private) Certificate Auhority which will issue these certificates.","title":"Describing the overall Compute Pods system"}]}